/* PKI_X509 object management */

#include <libpki/pki.h>

/* Static function for managing read callbacks for auto format downloading */

static void * __get_data_callback (PKI_MEM *io, const PKI_X509_CALLBACKS *cb,
				PKI_DATA_FORMAT format, PKI_CRED *cred);

/* -------------------------- X509 mem Operations -------------------- */

/*! \brief Reads a PKI_X509 object from a PKI_MEM */

PKI_X509 *PKI_X509_get_mem ( PKI_MEM *mem, PKI_DATATYPE type, 
						PKI_DATA_FORMAT format, PKI_CRED *cred, HSM *hsm ) {

	PKI_X509_STACK *sk = NULL;
	PKI_X509 *ret = NULL;

	if((sk = PKI_X509_STACK_get_mem ( mem, type, format, cred, hsm )) == NULL ) {
		return NULL;
	}

	ret = PKI_STACK_X509_pop ( sk );
	PKI_STACK_X509_free ( sk );

	return ret;
}

void * PKI_X509_get_mem_value ( PKI_MEM *mem, PKI_DATATYPE type,
						PKI_DATA_FORMAT format, PKI_CRED *cred, HSM *hsm ) {
	PKI_X509 *tmp = NULL;
	void *ret = NULL;

	if(( tmp = PKI_X509_get_mem ( mem, type, format, cred, hsm )) == NULL ) {
		return NULL;
	}

	if ( tmp->value ) {
		ret = tmp->value;
		tmp->value = NULL;
	}

	PKI_X509_free ( tmp );

	return ret;
}


static void * __get_data_callback(PKI_MEM *mem, const PKI_X509_CALLBACKS *cb,
				PKI_DATA_FORMAT format, PKI_CRED *cred ) {

	PKI_IO *ro = NULL;

	void *ret = NULL;
	char *pwd = NULL;

	// Checks the input
	if (!mem || !mem->data || !cb) {
		PKI_ERROR(PKI_ERR_PARAM_NULL, NULL);
		return NULL;
	}

	if (mem->size <= 0) {
		PKI_ERROR(PKI_ERR_PARAM_RANGE, NULL);
		return NULL;
	}

	// If we have credentials (password type), let's get a reference to it
	if (cred && cred->password) pwd = (char *) cred->password;

	// Create a read only memory buffer - it's faster than a read/write one
	if( (ro = BIO_new_mem_buf(mem->data, (int)mem->size)) == NULL) {
		PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);
		return NULL;
	}

	// Use the different callbacks depending on the data format
	switch ( format )
	{
		case PKI_DATA_FORMAT_PEM: {
			if( cb->read_pem ) {
				// Read PEM formatted data
				ret = cb->read_pem(ro, NULL, NULL, pwd);
			} else {
				// No support for data decoding
				PKI_DEBUG("No Callback for PEM decoding");
			}
		} break;

		case PKI_DATA_FORMAT_ASN1: {
			if( cb->read_der ) {
				// Read DER formatted data
				ret = cb->read_der(ro, NULL );
			} else {
				// No support for data decoding
				PKI_DEBUG("No Callback for DER decoding");
			}
		} break;

		case PKI_DATA_FORMAT_TXT: {
			if ( cb->read_txt ) {
				// Read TXT formatted data
				ret = cb->read_txt(ro, NULL );
			} else {
				// No support for data decoding
				PKI_DEBUG("No Callback for TXT decoding");
			}
		} break;

		case PKI_DATA_FORMAT_B64: {
			
			if (cb->read_b64) {
				// Read B64 formatted data
				ret = cb->read_b64(ro, NULL);

			} else if (cb->read_der) {

				// Temporary Duplicate Memory
				PKI_MEM * dup_mem = NULL;

				// We need to duplicate the buffer as PKI_MEM_decode()
				// alter the contents of the buffer
				if ((dup_mem = PKI_MEM_dup(mem)) == NULL) {
					// Here we duplicate the data to avoid issues with
					// the double decoding (if the first fails the data
					// would be altered, we want to be able to work on
					// the original data)
					PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);
					break;
				}

				if (PKI_MEM_decode(dup_mem, PKI_DATA_FORMAT_B64, 1) == PKI_ERR &&
					PKI_MEM_decode(dup_mem, PKI_DATA_FORMAT_B64, 0) == PKI_ERR) {
					// Can not B64 decode
					PKI_ERROR(PKI_ERR_DATA_FORMAT_UNKNOWN, NULL);
					// Free Memory
					PKI_MEM_free(dup_mem);
					// All Done
					break;
				}

				// Close the current BIO
				BIO_free_all(ro);
				ro = NULL;

				// Checks we have data to duplicate, if not, we are done
				if (!dup_mem->data || dup_mem->size <= 0) break;

				// Create a read only memory buffer for further usage it's faster
				// than a read/write one
				if ((ro = BIO_new_mem_buf(dup_mem->data, 
										(int)dup_mem->size)) == NULL) {
					// Error, can not allocate another RO BIO
					PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);
					// Free Memory
					PKI_MEM_free(dup_mem);
					dup_mem = NULL; //Safety
					break;
				}

				// Free Memory
				if (dup_mem) PKI_MEM_free(dup_mem);

				// And use the DER reader to retrieve the
				// requested object
				ret = cb->read_der(ro, NULL);

			} else {
				// No support for data decoding
				PKI_DEBUG("No Callback for B64 decoding");
			}
		} break;

		case PKI_DATA_FORMAT_XML: {

			if ( cb->read_xml ) {
				// Read XML formatted data
				ret = cb->read_xml(ro, NULL );
			} else {
				// No support for data decoding
				PKI_DEBUG("No Callback for XML decoding");
			}
		} break;

		case PKI_DATA_FORMAT_URL: {
			// No support for data decoding
			PKI_DEBUG("No Callback for URL decoding");
		} break;

		default: {
			PKI_ERROR(PKI_ERR_DATA_FORMAT_UNKNOWN, NULL);
		} break;
	}

	// Free the Read-Only I/O
	if (ro) BIO_free_all(ro);

	// All Done
	return ret;
}

/*! \brief Returns a stack of objects read from the passed PKI_MEM */

PKI_X509_STACK *PKI_X509_STACK_get_mem ( PKI_MEM *mem, PKI_DATATYPE type,
			PKI_DATA_FORMAT format, PKI_CRED *cred, HSM *hsm ) {

	PKI_X509        * x_obj = NULL;
	PKI_X509_STACK  * sk    = NULL;
	PKI_DATA_FORMAT   i     = PKI_DATA_FORMAT_PEM;

	const PKI_X509_CALLBACKS *cb = NULL;

	// Checks for valid input
	if( !mem || mem->size <= 0 ) return NULL;

	if((cb = PKI_X509_CALLBACKS_get(type, hsm)) == NULL)
	{
		// We have not found the callbacks - we can not proceed
		// forward. Report the error and return NULL
		PKI_log_debug("Object type not supported [%d]", type);
		return NULL;
	}

	/* Check we have a good type */
	if((x_obj = PKI_X509_new (type, hsm)) == NULL)
	{
		// The object type is not supported, let's return NULL
		PKI_log_debug("Object type not supported [%d]", type);
		return NULL;
	}

	if((sk = PKI_STACK_X509_new()) == NULL )
	{
		// Memory allocation error
		PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);

		// Free reserved memory and return NULL
		PKI_X509_free(x_obj);

		// Nothing to return
		return NULL;
	}

	// We cycle through the different data types we support to enable
	// automatic data conversion on load.
	//
	// NOTE: we start from 1 as this is the first valid one after the
	//       unknown datatype (PKI_DATATYPE_UNKNOW)
	for (i = PKI_DATA_FORMAT_START; i < PKI_DATA_FORMAT_END; i++) {

			// Fix for older applications using -1 as format
		if (format == 4294967295) {
			PKI_DEBUG("Wrong DATA format used in application (-1),"
				"please replace with PKI_DATA_FORMAT_UNKNOWN (%d)", 
				PKI_DATA_FORMAT_UNKNOWN);
		}

		// A Format was selected, so we skip the others
		if (format != 4294967295 && 
		    format != PKI_DATA_FORMAT_UNKNOWN && 
			format != i) {
			
			// We cannot process the type, skipping.
		    continue;
		}

		if ((x_obj->value = __get_data_callback(mem, cb, i, cred)) != NULL) {

			// Let's add the right properties to the object
			x_obj->cred = PKI_CRED_dup(cred);
			x_obj->type = type;
			x_obj->hsm  = hsm;
			x_obj->cb = cb;
			x_obj->ref = NULL;

			// Let's now save the object on the stack and return
			PKI_STACK_X509_push(sk, x_obj);

			// We managed to load the object, let's break the for loop
			return (sk);
		}
	}

	// If we reach here, no object was found - let's free the memory
	// and return null
	if (x_obj) PKI_X509_free(x_obj);
	if (sk)    PKI_STACK_X509_free(sk);

	// Let's return null
	return NULL;
}

/*! \brief Writes a PKI_X509 object to a PKI_MEM structure */

PKI_MEM *PKI_X509_put_mem (PKI_X509 *x, PKI_DATA_FORMAT format, 
				PKI_MEM **mem, PKI_CRED *cred ) {

	PKI_DATATYPE type = PKI_DATATYPE_UNKNOWN;

	// Checks the input
	if (!x || !x->value)
	{
		PKI_ERROR(PKI_ERR_PARAM_NULL, NULL);
		return ( NULL );
	}

	// Verifies we have the right set of callbacks attached to the
	// object we need to decode to memory
	if (!x->cb)
	{
		PKI_ERROR(PKI_ERR_CALLBACK_NULL, NULL);
		return NULL;
	}

	// Checks it is a supported datatype, if not - let's return null
	if ((type = PKI_X509_get_type ( x )) == PKI_DATATYPE_UNKNOWN)
	{
		PKI_ERROR(PKI_ERR_OBJECT_CREATE, NULL);
		return NULL;
	}

	// We need to be sure that the data structures are properly updated
	PKI_X509_set_modified ( x );

	// Returns the actual PKI_MEM with the encoded value
	return PKI_X509_put_mem_value ( x->value, type, mem, 
					format, cred, x->hsm );
}

/*! \brief Writes a PKI_X509_XXX_VALUE to a PKI_MEM structure */

PKI_MEM *PKI_X509_put_mem_value (void *x, PKI_DATATYPE type, 
			PKI_MEM **pki_mem, PKI_DATA_FORMAT format, 
				PKI_CRED *cred, HSM *hsm)
{

	PKI_IO *membio = NULL;
	const PKI_X509_CALLBACKS *cb = NULL;
	PKI_MEM *ret = NULL;
	int rv = 0;

	char *pwd = NULL;
	const EVP_CIPHER *enc = NULL;

	if ((membio = BIO_new(BIO_s_mem())) == NULL)
	{
		PKI_ERROR(PKI_ERR_OBJECT_CREATE, NULL);
		return NULL;
	}

	if ((cb = PKI_X509_CALLBACKS_get(type, hsm)) == NULL)
	{
		PKI_ERROR(PKI_ERR_CALLBACK_NULL, NULL);
		return NULL;
	}

	/* Check if we have to encrypt the key */
	if (cred && cred->password && strlen(cred->password) > 0)
	{
		pwd = (char *) cred->password;
		enc=EVP_aes_256_cbc();
	}
	else
	{
		enc=NULL;
	}

	switch (format)
	{
		case PKI_DATA_FORMAT_PEM: {
			if (cb->to_pem_ex) {
				rv = cb->to_pem_ex(membio, x, (void *) enc, NULL, 0, NULL, pwd );
			} else if (cb->to_pem) {
				rv = cb->to_pem ( membio, x );
			} else {
				PKI_DEBUG("No Callback for PEM encoding [Obj Type: %d, Format: %d]", type, format);
			}
		} break;

		case PKI_DATA_FORMAT_URL:
		case PKI_DATA_FORMAT_ASN1: {
			if (cb->to_der) {
				rv = cb->to_der ( membio, x );
			} else {
				PKI_DEBUG("No Callback for DER encoding [Obj Type: %d, Format: %d]", type, format);
			}
		} break;

		case PKI_DATA_FORMAT_TXT: {
			if (cb->to_txt) rv = cb->to_txt ( membio, x );
			else PKI_DEBUG("No Callback for TXT encoding [Obj Type: %d, Format: %d]", type, format);
		} break;

		case PKI_DATA_FORMAT_B64: {

			if (cb->to_b64)	{

				rv = cb->to_b64 ( membio, x );

			} else if (cb->to_der) {

				rv = cb->to_der(membio, x);

				if ((ret = PKI_MEM_new_bio(membio, pki_mem)) != NULL ) {
					rv = PKI_MEM_encode(ret, PKI_DATA_FORMAT_B64, 1);

					if (rv != PKI_OK) rv = 0; // We align with the callbacks ret codes
				} else {
					rv = 0;
				}
			} else { 
				PKI_DEBUG("No Callback for B64 encoding [Obj Type: %d, Format: %d]", type, format);
			}
		} break;

		case PKI_DATA_FORMAT_XML: {
			if (cb->to_xml) {
				rv = cb->to_xml( membio, x );
			} else PKI_DEBUG("No Callback for XML encoding [Obj Type: %d, Format: %d]", type, format);
		} break;

		case PKI_DATA_FORMAT_UNKNOWN:
		default: {
			PKI_DEBUG("Unsupported/Unknown encoding [Obj Type: %d, Format: %d]", type, format);
			rv = 0;
		} break;
	}

	/* We already covered the case of B64 without a specific encoding callback */
	if ((format != PKI_DATA_FORMAT_B64) || (cb->to_b64 != NULL))
	{
		if (rv != 0)
		{
			if ((ret = PKI_MEM_new_bio(membio, pki_mem)) == NULL )
			{
				PKI_log_err ("Can not convert BIO");
				if (membio) BIO_free_all (membio);
				return NULL;
			}
		}
		else
		{
			/* OpenSSL ERROR! */
			if (membio) BIO_free_all(membio);
			return ( NULL );
		}
	}

	BIO_free_all(membio);

	return ret;
}

/*! \brief Writes a stack of PKI_X509 to a PKI_MEM */

PKI_MEM * PKI_X509_STACK_put_mem ( PKI_X509_STACK *sk, PKI_DATA_FORMAT format, 
				PKI_MEM **pki_mem, PKI_CRED *cred, HSM *hsm ) {

	PKI_MEM *ret = NULL;
	int i = 0;

	// Input Checking
	if (!sk) {
		PKI_ERROR(PKI_ERR_PARAM_NULL, NULL);
		return NULL;
	}

	// Checks we have a good container, otherwise create one
	if ( pki_mem != NULL ) {
		if( *pki_mem == NULL ) {
			if((*pki_mem = PKI_MEM_new_null()) == NULL ) {
				PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);
				return NULL;
			}
			ret = *pki_mem;
		} else {
			ret = *pki_mem;
		}
	} else {
		ret = PKI_MEM_new_null();
	}

	// Checks for memory allocation
	if (!ret) {
		PKI_ERROR(PKI_ERR_MEMORY_ALLOC, NULL);
		return NULL;
	}

	// Cycles through all elements in the stack
	for( i = 0; i < PKI_STACK_X509_elements ( sk ); i++ ) {
		PKI_X509 *x_obj = NULL;
		PKI_MEM *tmp_mem = NULL;

		if((x_obj = PKI_STACK_X509_get_num( sk, i )) != NULL) {

			if((tmp_mem = PKI_X509_put_mem ( x_obj, 
					format, pki_mem, cred )) == NULL ) {
				PKI_log_debug("ERROR adding item %d to PKI_MEM", i);
				continue;
			}

			if ( x_obj->cred ) PKI_CRED_free ( x_obj->cred );
			if ( cred ) x_obj->cred = PKI_CRED_dup ( cred );
		}
	}

	return ret;
}

